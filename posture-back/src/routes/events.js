import express from 'express';
import { pool } from '../db.js';
const router = express.Router();

async function ensureOpenSession(client, user_id, ts){
  const { rows } = await client.query(
    'SELECT session_id FROM sessions WHERE user_id=$1 AND end_ts IS NULL LIMIT 1',
    [user_id]
  );
  if(rows.length === 0){
    const r = await client.query(
      'INSERT INTO sessions (user_id, start_ts) VALUES ($1,$2) RETURNING session_id',
      [user_id, ts]
    );
    return r.rows[0].session_id;
  }
  return rows[0].session_id;
}

router.post('/', async (req, res) => {
  const payload = req.body || {};
  const { event, user_id, prev_user_id, ts } = payload;
  if(!event || !ts){
    return res.status(400).json({error:'event and ts are required'});
  }
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    let session_id = null;

    if(event === 'login' || event === 'relogin'){
      if(!user_id){ throw new Error('user_id required for login/relogin'); }
      session_id = await ensureOpenSession(client, user_id, ts);
    } else if(event === 'absent'){
      if(!prev_user_id){ throw new Error('prev_user_id required for absent'); }
      // close any open session for prev_user_id
      const r = await client.query(
        'UPDATE sessions SET end_ts=$1 WHERE user_id=$2 AND end_ts IS NULL RETURNING session_id',
        [ts, prev_user_id]
      );
      session_id = r.rows[0]?.session_id || null;
    } else if(event === 'register_commit'){
      if(!user_id){ throw new Error('user_id required for register_commit'); }
      // ensure user exists (id can be pre-generated by client; if not, create)
      await client.query(
        'INSERT INTO users (user_id) VALUES ($1) ON CONFLICT (user_id) DO NOTHING',
        [user_id]
      );
      // upsert embedding if provided
      if(payload.embedding?.vec){
        const dim = payload.embedding.dim ?? 128;
        const l2 = payload.embedding.l2_normalized ?? true;
        await client.query(
          'INSERT INTO embeddings (user_id, vec, dim, l2_normalized) VALUES ($1,$2,$3,$4)',
          [user_id, payload.embedding.vec, dim, l2]
        );
      }
      // upsert calibration baseline if provided
      if(payload.baseline_box){
        const b = payload.baseline_box;
        await client.query(
          `INSERT INTO calibration_baselines (user_id, box_x, box_y, box_w, box_h)
           VALUES ($1,$2,$3,$4,$5)
           ON CONFLICT (user_id) DO UPDATE SET box_x=EXCLUDED.box_x, box_y=EXCLUDED.box_y, box_w=EXCLUDED.box_w, box_h=EXCLUDED.box_h, updated_at=now()`,
          [user_id, b.x, b.y, b.width, b.height]
        );
      }
    }

    // event_logs (best-effort)
    const evtUser = user_id ?? prev_user_id ?? null;
    const evtSess = session_id ?? null;
    await client.query(
      'INSERT INTO event_logs (event, session_id, user_id, ts, payload) VALUES ($1,$2,$3,$4,$5)',
      [event, evtSess, evtUser, ts, payload]
    );

    await client.query('COMMIT');
    res.json({status:'ok', session_id: evtSess});
  } catch (e){
    await pool.query('ROLLBACK');
    res.status(400).json({error: e.message});
  } finally {
    client.release();
  }
});

export default router;
